<br><b> Выполнение

<br>• Подключились к ВМ с Postgresql, созданной в VirtualBox и скачали базу данных по полётам за три месяца:

wget https://edu.postgrespro.ru/demo-medium.zip

<br>• Запускаем скаченный SQL-скрипт и тем самым устанавливаем базу demo:

psql -f demo-medium-20170815.sql -U postgres -p 5433

<br>• Проверяем созданные таблицы из базы demo и делаем тестовый запрос к таблице bookings.bookings за 2й квартал:

explain analyze

select *

from bookings.bookings B

where B.book_date between '2017-04-01' and date'2017-07-01'-1

order by book_date

<br>• План запроса:

Sort  (cost=49431.29..50249.75 rows=327383 width=21) (actual time=230.158..293.738 rows=327410 loops=1)

  Sort Key: book_date
  
  Sort Method: external merge  Disk: 10560kB
  
  ->  Seq Scan on bookings b  (cost=0.00..12725.49 rows=327383 width=21) (actual time=0.040..104.877 rows=327410 loops=1)
  
    Filter: ((book_date >= '2017-04-01 00:00:00+05'::timestamp with time zone) AND (book_date <= '2017-06-30'::date))
        
    Rows Removed by Filter: 266023
        
Planning Time: 0.198 ms

Execution Time: 311.637 ms

<br>• Решено секционировать таблицу bookings.bookings по-кварталам

<br>• Создаём секционированную таблицу bookings.bookings_by_range по полю book_date на каждый квартал с 2017г. по 2018г. (для надёжности) и вставляем в неё данные из таблицы bookings.bookings

<br>• Производим тестирование секционированной таблицы. Тест 0 - получаем данные за втрой квартал:

analyze bookings.bookings_by_range

explain analyze  

select *

from bookings.bookings_by_range B

where B.book_date between '2017-04-01' and date'2017-07-01'-1

order by book_date

<br>• План:

Sort  (cost=51042.84..51861.64 rows=327519 width=21) (actual time=203.556..252.805 rows=327410 loops=1)

  Sort Key: b.book_date
  
  Sort Method: external merge  Disk: 10560kB
  
  ->  Append  (cost=0.00..14320.10 rows=327519 width=21) (actual time=0.053..91.502 rows=327410 loops=1)
  
        Subplans Removed: 6
        
        ->  Seq Scan on bookings_by_range_2017_2 b_1  (cost=0.00..7111.91 rows=327513 width=21) (actual time=0.053..62.936 rows=327410 loops=1)
        
              Filter: ((book_date >= '2017-04-01 00:00:00+05'::timestamp with time zone) AND (book_date <= '2017-06-30'::date))
              
              Rows Removed by Filter: 5384
              
Planning Time: 0.636 ms

Execution Time: 267.800 ms

<br>• Результаты лучше, но почти сопоставимы. Т.к. первичный ключ и на исходной таблице и на секционированной таблицы одинаковый и пришлось получать все данные из секционированной таблицы bookings_by_range_2017_2

До:

Execution Time: 311.637 ms

После:

Execution Time: 267.800 ms


<br>• Производим Тест 1. Получаем данные за 10 дней из исходной таблицы:

analyze bookings.bookings
explain analyze  
select *
from bookings.bookings B
where B.book_date between '2017-07-01' and '2017-07-10'
order by book_date

План:

Gather Merge  (cost=10029.68..14897.82 rows=41724 width=21) (actual time=62.819..89.532 rows=49874 loops=1)

  Workers Planned: 2
  
  Workers Launched: 2
  
  ->  Sort  (cost=9029.66..9081.81 rows=20862 width=21) (actual time=27.184..29.808 rows=16625 loops=3)
  
        Sort Key: book_date
        
        Sort Method: quicksort  Memory: 2199kB
        
        Worker 0:  Sort Method: quicksort  Memory: 25kB
        
        Worker 1:  Sort Method: quicksort  Memory: 1675kB
        
        ->  Parallel Seq Scan on bookings b  (cost=0.00..7532.96 rows=20862 width=21) (actual time=0.010..21.376 rows=16625 loops=3)
        
              Filter: ((book_date >= '2017-07-01 00:00:00+05'::timestamp with time zone) AND (book_date <= '2017-07-10 00:00:00+05'::timestamp with time zone))
              
              Rows Removed by Filter: 181186
              
Planning Time: 0.799 ms

Execution Time: 92.267 ms

<br>• Такой же запрос, только из секционированной таблицы:

analyze bookings.bookings

explain analyze  

select *

from bookings.bookings B

where B.book_date between '2017-07-01' and '2017-07-10'

order by book_date

<br>• План:

Sort  (cost=9450.32..9574.66 rows=49734 width=21) (actual time=36.922..43.162 rows=49874 loops=1)

  Sort Key: b.book_date
  
  Sort Method: quicksort  Memory: 3874kB
  
  ->  Seq Scan on bookings_by_range_2017_3 b  (cost=0.00..5570.59 rows=49734 width=21) (actual time=0.011..26.742 rows=49874 loops=1)
  
        Filter: ((book_date >= '2017-07-01 00:00:00+05'::timestamp with time zone) AND (book_date <= '2017-07-10 00:00:00+05'::timestamp with time zone))
        
        Rows Removed by Filter: 210765
        
Planning Time: 0.276 ms

Execution Time: 45.244 ms

<br>• Результаты в два раза лучше.

До:

Execution Time: 92.267 ms

После:

Execution Time: 45.244 ms

<br>• Производим Тест 2. Получаем данные за конкретную дату:

explain analyze  

select *

from bookings.bookings B

where B.book_date='2017-07-05 05:12:00+05'

order by book_date

<br>• План:

Gather  (cost=1000.00..7915.20 rows=4 width=21) (actual time=0.360..59.099 rows=6 loops=1)

  Workers Planned: 2
  
  Workers Launched: 2
  
  ->  Parallel Seq Scan on bookings b  (cost=0.00..6914.80 rows=2 width=21) (actual time=5.002..37.123 rows=2 loops=3)
  
        Filter: (book_date = '2017-07-05 05:12:00+05'::timestamp with time zone)
        
        Rows Removed by Filter: 197809
        
Planning Time: 0.098 ms

Execution Time: 59.148 ms

<br>• Такой же запрос, только из секционированной таблицы:

explain analyze  

select *

from bookings.bookings B

where B.book_date='2017-07-05 05:12:00+05'

order by book_date

<br>• План:

Gather  (cost=1000.00..4577.86 rows=4 width=21) (actual time=0.458..22.971 rows=6 loops=1)

  Workers Planned: 1
  
  Workers Launched: 1
  
  ->  Parallel Seq Scan on bookings_by_range_2017_3 b  (cost=0.00..3577.46 rows=2 width=21) (actual time=0.185..13.795 rows=3 loops=2) 
  
        Filter: (book_date = '2017-07-05 05:12:00+05'::timestamp with time zone)
        
        Rows Removed by Filter: 130316
        
Planning Time: 0.122 ms

Execution Time: 22.996 ms

<br>• Результаты почти в три раза лучше.

До:

Execution Time: 59.148 ms

После:

Execution Time: 22.996 ms

<br>• Производим Тест 3. Вставка, обновление и удаление данных:

INSERT INTO bookings.bookings_by_range

(book_ref, book_date, total_amount)

VALUES('A59A1O', '2017-07-05 05:05:00.000', 555);

INSERT INTO bookings.bookings_by_range

(book_ref, book_date, total_amount)

VALUES('A59A1B', '2017-07-06 06:06:00.000', 100);

INSERT INTO bookings.bookings_by_range

(book_ref, book_date, total_amount)

VALUES('A59A1A', '2017-07-07 07:07:00.000', 200);

delete from bookings.bookings_by_range where book_ref in ('A59A1O','A59A1B');

update bookings.bookings_by_range set total_amount = 500 where book_ref = 'A59A1A';

select * from bookings.bookings_by_range where book_ref in ('A59A1A');

<br>• Операции выполнены успешно.

<br>• Вывод: секционирование таблицы позволило ускорить запросы по ключу секционирования.

<img width="1765" height="1101" alt="1" src="https://github.com/user-attachments/assets/f9ab7e81-8fc4-4dcf-a198-587d1e8f073c" />
<br>
<br>
<img width="1751" height="856" alt="2" src="https://github.com/user-attachments/assets/8fdfc7a4-a00f-406c-a8cc-20e48e8764c7" />
<br>
<br>
<img width="1765" height="992" alt="3" src="https://github.com/user-attachments/assets/83696f81-5d1f-4e7d-8531-3955bab8a305" />
<br>
<br>
<img width="1765" height="1103" alt="4" src="https://github.com/user-attachments/assets/68c475f3-a376-4922-8297-62995cec5e0c" />
<br>
<br>
<img width="1763" height="1246" alt="5" src="https://github.com/user-attachments/assets/dc3dfe12-4661-4c7e-aceb-acebb5f1e530" />
<br>
<br>
<img width="1744" height="1295" alt="6" src="https://github.com/user-attachments/assets/b3d34c71-ffbd-4135-9d1a-7fd2136cb3ca" />
